原码、反码、补码、移码

一、原码

原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值.

符号位：

0表示+

1表示-

8位二进制:

[+1]原 = 0000 0001

[-1]原 = 1000 0001

二、反码

反码的表示方法是：正数的反码是其本身；负数的反码是在其原码的基础上, 符号位不变，其余各个位取反。

[+1] = [00000001]原 = [00000001]反

[-1] = [10000001]原 = [11111110]反

三、补码

补码的表示方法是：正数的补码就是其本身；负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. 

负数的补码等于反码末位加1。

X=-101011 , [X]原= 10101011 ，[X]反=11010100，[X]补=11010101

[+1] = [00000001]原 = [00000001]反 = [00000001]补

0的补码是唯一的，如果机器字长为8那么[0]补=00000000

四、移码

移码等于补码的符号（第一位数字）位取反。

同一数值的移码与补码符号位相反，其它各位相同。

 

原码中0有两种表示方式：[+0]原=0000000，[-0]原=1000000。
在反码表示中，0也有两种表示形式：[+0]反=0000000，[-0]反=11111111。
在补码表示中，0有唯一的编码：[+0]补=0000000，[-0]补=0000000。

[-1] = [10000001]原 = [11111110]反 = [11111111]补。
或者用这个思路：
-1的补码 = 1的原码取反+1 = 00000001取反+1 = 11111110+1 = 11111111

计算机中存储数据用的是补码，所以1和-1分别存储为:
1：00000001
-1:11111111

但是，java中，int型是32位，所以1和-1分别是:
1：00000000 00000000 00000000 00000001
-1:11111111 11111111 11111111 11111111
如果在java中写sout(0b11111111)显示的是255，而不是-1
因为java中sout(0b11111111)是sout(0b00000000000000000000000011111111)，而不是sout(0b11111111111111111111111111111111)
 

正数的原码，补码，反码相同；
负数的反码：原码的数值取反；
负数的补码：原码转换成反码，反码末位加1
负数的移码：与补码的符号位（第一位数字）相反


-1 = ~1+1 负数=正数的原码取反+1
1的原码：	00000000 00000000 00000000 00000001
1的原码取反~1： 11111111 11111111 11111111 11111110
~+1	     ： 11111111 11111111 11111111 11111111
~+1= -1      ： 11111111 11111111 11111111 11111111

-2147483647在java中作为int表示为
0b10000000000000000000000000000001
这是-2147483647的补码，不是原码
System.out.println(0b10000000000000000000000000000001);// -2147483647
如何得到-2147483647的原码呢？可以用下面的方法：
-2147483647的补码 = ~2147483647的原码+1，也就是-2147483647的补码=2147483647的原码取反+1，那么
2147483647的原码= ~(-2147483647的补码-1) = ~(10000000000000000000000000000001-1)= 011111111111111111111111111111111
那么-2147483647的原码 = -011111111111111111111111111111111 = 111111111111111111111111111111111，第一个1表示符号为负

windows 10 自带的计算器表示整数用的是64位
